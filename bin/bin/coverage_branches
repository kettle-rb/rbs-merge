#!/usr/bin/env ruby
# frozen_string_literal: true

# Analyze branch coverage from SimpleCov JSON output
# Usage: bin/coverage_branches [options] [coverage.json path]
#   -d, --detail     Show detailed uncovered branch locations
#   -f, --file FILE  Show details for specific file (partial match)

require "json"

# Parse options
show_detail = ARGV.delete("-d") || ARGV.delete("--detail")
file_filter = nil
if (idx = ARGV.index("-f") || ARGV.index("--file"))
  ARGV.delete_at(idx)
  file_filter = ARGV.delete_at(idx)
end

coverage_path = ARGV[0] || "coverage/coverage.json"

unless File.exist?(coverage_path)
  puts "Coverage file not found: #{coverage_path}"
  puts "Run bin/rspec first to generate coverage data."
  exit 1
end

data = JSON.parse(File.read(coverage_path))
files = data["coverage"]

results = []

files.each do |path, info|
  next unless info.is_a?(Hash)
  next unless info["branches"]

  branches = info["branches"]
  total = 0
  covered = 0
  uncovered_details = []

  # Handle both Hash format (older SimpleCov) and Array format (newer SimpleCov)
  if branches.is_a?(Hash)
    branches.each do |condition_key, branch_data|
      next unless branch_data.is_a?(Hash)

      branch_data.each do |branch_id, hit_count|
        total += 1
        if hit_count.to_i > 0
          covered += 1
        else
          # Parse branch info: condition_key format is like "[:if, 0, 45, 8, 50, 11]"
          # branch_id format is like "[:then, 1, 46, 10, 46, 35]"
          begin
            cond_info = begin
              eval(condition_key)
            rescue
              nil
            end
            branch_info = begin
              eval(branch_id)
            rescue
              nil
            end
            if cond_info && branch_info
              cond_type = cond_info[0]
              cond_line = cond_info[2]
              branch_type = branch_info[0]
              branch_line = branch_info[2]
              uncovered_details << {
                condition: cond_type,
                cond_line: cond_line,
                branch: branch_type,
                branch_line: branch_line,
              }
            end
          rescue
            # Ignore parse errors
          end
        end
      end
    end
  elsif branches.is_a?(Array)
    # Array of branch objects: [{type:, start_line:, end_line:, coverage:}, ...]
    branches.each do |branch|
      next unless branch.is_a?(Hash)

      total += 1
      if branch["coverage"].to_i > 0
        covered += 1
      else
        uncovered_details << {
          condition: branch["type"],
          cond_line: branch["start_line"],
          branch: branch["type"],
          branch_line: branch["start_line"],
        }
      end
    end
  end

  uncovered = total - covered
  next if uncovered == 0

  pct = (total > 0) ? (covered.to_f / total * 100).round(1) : 100.0
  short_path = path.split("/lib/").last || path.split("/").last(2).join("/")

  results << {
    uncovered: uncovered,
    total: total,
    covered: covered,
    pct: pct,
    path: short_path,
    full_path: path,
    details: uncovered_details.sort_by { |d| d[:branch_line] || 0 },
  }
end

# Sort by uncovered branches descending
results.sort_by! { |r| -r[:uncovered] }

# Filter by file if specified
if file_filter
  results.select! { |r| r[:path].include?(file_filter) || r[:full_path].include?(file_filter) }
end

puts "Files with uncovered branches:"
puts "-" * 70
results.each do |r|
  puts format("%3d uncovered | %5.1f%% | %s", r[:uncovered], r[:pct], r[:path])

  if show_detail && r[:details].any?
    r[:details].each do |d|
      puts format(
        "      Line %3d: %s -> %s branch not taken",
        d[:branch_line] || d[:cond_line] || 0,
        d[:condition],
        d[:branch],
      )
    end
  end
end
puts "-" * 70
total_uncovered = results.sum { |r| r[:uncovered] }
total_branches = results.sum { |r| r[:total] }
puts format("Total: %d uncovered branches out of %d", total_uncovered, total_branches)
